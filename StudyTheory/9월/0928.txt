mysql을 사용한 DB 연결
mysql은 DB의 대표적인 DBMS이며, node에서 연결하기위해선 mysql2를 다운로드해야한다.
-> npm install mysql2

pool과 connection을 생성해주어야한다.


Pool
pool의 개념은 보따리라 생각해도된다.
query를 실행하게 되면 해당 query실행을 위해서 mysql 프로그램을 실행하고, 
해당 구문에 대한 값을 가져온다음 다시 프로그램을 닫아야한다.

주의할 점은 해당 query는 각 한줄에 따라서 위의 과정을 실행해야하고,
이런 query문이 여러개일수록 속도 저하가 일어날 수 밖에 없다.
때문에 중간에 어떤 임시저장공간을 만들어 해당 데이터들을 담아두는 방식으로 조금더 향상시킬 수 있는데
이때 사용되는게 pool이다.


util/database.js 를통해서 db에 접속을 하게되고
쿼리문을 실행했을때(db.execute()) 뒤에 then().catch()가 붙는다.

이는 util/database.js에서 promise를 통해서 exports시켰기때문인데 때문에
promise에 대한 내용을 공부해야한다.

promise 자바스크립트 기본 객체이다.
비동기로 이뤄진 자바스크립트에서 동기로 동작해야 하는 부분을 만들때 사용하는 객체.
ex) 목표 : 데이터 가져오기
          1. DB에 접속한다.
          2. 원하는 쿼리문을 통해 데이터를 가져온다.
          3. 데이터를 가공하여 원하는 곳에 뿌린다.
    -> 나올 수 있는 문제 = 데이터를 모두 가져오기전에 다음 코드가 실행될 수 있다.

문법 = promise().then().catch()
    -> 의문점 : promise와 try-catch문은 비슷한 거 같다. 어떤 차이가 있는가?
    -> promise와 try-catch는 같은 느낌이라 봐도 좋다.
    -> 다만 try-catch문의 경우 말그대로 오류 제어문의 영역이고
    -> promise의 경우 비동기,동기에 대한 제어문이다.
    -> 때문에 더 자세히 찾아봐야되는 부분은
    = async와 await, 그리고 promise의 차이점이다.


------------------------------------
현재구조
- data/products.json 파일에 원하는 제품에 대한 정보를 집어넣고 있다.

이후 학습하게 되는 내용
- 로컬파일에 저장하던 내용을 DB로 저장시킨다.
--------------------------------------

model/products 파일을 변경하고 있던 중
promise를 통해서 받아온 값이니 당연히 FetchAll 안에 then을 사용해야할줄알았지만
사실 FetchAll 내부에서 가공하는것이 아닌, FetchAll을 사용하는 곳에서 가공하는것이다.


리펙토링
- 모든 데이터전송에 대해서 기존 로컬파일로 지정되어있던 내용을 모두 DB연동으로 변경해야한다.

sql에서 insert문을 실행할 때 ${}를 통해서 데이터를 집어넣지 못했다 = 이유를 모름..
